{
  "__type__": "cc.AnimationClip",
  "_name": "zxV7YKctW4Jvdp",
  "_objFlags": 0,
  "_native": "",
  "_duration": 0.9,
  "sample": 60,
  "speed": 1,
  "wrapMode": 2,
  "curveData": {
    "props": {
      "scale": [
        {
          "frame": 0,
          "value": {
            "__type__": "cc.Vec3",
            "x": 1,
            "y": 1,
            "z": 1
          },
          "curve": [
            0.6,
            -0.27,
            0.73,
            0.04
          ]
        },
        {
          "frame": 0.4666666666666667,
          "value": {
            "__type__": "cc.Vec3",
            "x": 1.15,
            "y": 1.15,
            "z": 1
          },
          "curve": "quadOut"
        },
        {
          "frame": 0.9,
          "value": {
            "__type__": "cc.Vec3",
            "x": 1,
            "y": 1,
            "z": 1
          }
        }
      ]
    }
  },
  "events": []
}


//deserialize
function deserializeNode(serializedNode, parent = null) {
    // Helper function to deserialize components
    function deserializeComponent(node, serializedComponent) {
        let component;

        if (serializedComponent.type === "cc.Sprite") {
            component = node.addComponent(cc.Sprite);
            // Assuming spriteFrame is preloaded and can be found by name
            // component.spriteFrame = cc.spriteFrameCache.getSpriteFrame(serializedComponent._spriteName);
            component.sizeMode = serializedComponent.sizeMode;
            // Assuming color is set at the node level
        } else if (serializedComponent.type === "cc.Label") {
            component = node.addComponent(cc.Label);
            component.string = serializedComponent.string;
            component.fontSize = serializedComponent.fontSize;
            component.lineHeight = serializedComponent.lineHeight;
            component.horizontalAlign = serializedComponent.horizontalAlign;
            component.verticalAlign = serializedComponent.verticalAlign;
            // Assuming font is preloaded and can be found by name
            // component.font = cc.fontCache.getFont(serializedComponent._fontName);
        } else if (serializedComponent.type === "cc.Animation") {
            component = node.addComponent(cc.Animation);
            // Assuming clips are preloaded and can be found by name
            // component.clips = serializedComponent.clips.map(clipName => cc.animationCache.getAnimation(clipName));
        } else if (serializedComponent.type === "cc.Mask") {
            component = node.addComponent(cc.Mask);
            component.type = serializedComponent.type;
            component.segments = serializedComponent.segments;
            component.inverted = serializedComponent.inverted;
        } else if (serializedComponent.type === "cc.Widget") {
            component = node.addComponent(cc.Widget);
            component.isAlignTop = serializedComponent.isAlignTop;
            component.isAlignBottom = serializedComponent.isAlignBottom;
            component.isAlignLeft = serializedComponent.isAlignLeft;
            component.isAlignRight = serializedComponent.isAlignRight;
            component.isAlignHorizontalCenter = serializedComponent.isAlignHorizontalCenter;
            component.isAlignVerticalCenter = serializedComponent.isAlignVerticalCenter;
            component.top = serializedComponent.top;
            component.bottom = serializedComponent.bottom;
            component.left = serializedComponent.left;
            component.right = serializedComponent.right;
            component.horizontalCenter = serializedComponent.horizontalCenter;
            component.verticalCenter = serializedComponent.verticalCenter;
            component.alignMode = serializedComponent.alignMode;
        } else if (serializedComponent.type === "cc.Layout") {
            component = node.addComponent(cc.Layout);
            component.type = serializedComponent.layoutType;
            component.resizeMode = serializedComponent.resizeMode;
            component.cellSize = serializedComponent.cellSize;
            component.startAxis = serializedComponent.startAxis;
            component.paddingLeft = serializedComponent.paddingLeft;
            component.paddingRight = serializedComponent.paddingRight;
            component.paddingTop = serializedComponent.paddingTop;
            component.paddingBottom = serializedComponent.paddingBottom;
            component.spacingX = serializedComponent.spacingX;
            component.spacingY = serializedComponent.spacingY;
            component.verticalDirection = serializedComponent.verticalDirection;
            component.horizontalDirection = serializedComponent.horizontalDirection;
        } else {
            return null;
        }

        return component;
    }

    // Create the node
    const node = new cc.Node(serializedNode.name);

    // Set node properties
    node.setPosition(serializedNode.position.x, serializedNode.position.y);
    node.setRotation(serializedNode.rotation);
    node.setScale(serializedNode.scale.x, serializedNode.scale.y);
    node.setAnchorPoint(serializedNode.anchor.x, serializedNode.anchor.y);
    node.setContentSize(serializedNode.contentSize.width, serializedNode.contentSize.height);
    node.active = serializedNode.active;

    // Set node color and opacity if available
    if (serializedNode.color) {
        node.color = new cc.Color(serializedNode.color.r, serializedNode.color.g, serializedNode.color.b);
    }
    if (serializedNode.opacity !== undefined) {
        // const opacityComponent = node.addComponent(cc.UIOpacity);
        node.opacity = serializedNode.opacity;
    }

    // Deserialize and add components to the node
    if (serializedNode.components) {
        serializedNode.components.forEach((serializedComponent) => {
            deserializeComponent(node, serializedComponent);
        });
    }

    // Handle other components
    // if (serializedNode.otherComponents) {
    //     serializedNode.otherComponents.forEach(componentType => {
    //         node.addComponent(componentType);
    //     });
    // }

    // Recursively deserialize children
    if (serializedNode.children) {
        serializedNode.children.forEach((serializedChild) => {
            const childNode = deserializeNode(serializedChild, node);
            // node.addChild(childNode);
        });
    }

    // Add the node to its parent if provided
    if (parent) {
        parent.addChild(node);
    }

    return node;
}

// Example usage
const serializedData = {
    // This should be your actual serialized data
};
const rootNode = deserializeNode(serializedData);
console.log(rootNode);



// 用js实现序列化creator节点树， 传入一个Creator3.6版本的节点（cc.Node)，将节点序列化成一个Creator2.4版本的json。
// 需要包含常用的属性值，包含name属性，处理常用的组件：cc.Sprite, cc.Label, cc.Animation, cc.Mask, sp.Skeleton。
// cc.UIOpacity, cc.UITransform这些Creator2.4没有的组件不需要处理，只需把相应属性值赋给序列化后的对象。
// 其他未列出的组件，把组件名字以字符串数组的形式放在一个字段里即可，没有其他组件，则无此字段。
function serializeNode(node) {
    // Helper function to serialize components
    function serializeComponent(component) {
        const serialized = {};

        if (component instanceof cc.Sprite) {
            serialized.type = "cc.Sprite";
            // serialized.spriteFrame = component.spriteFrame ? component.spriteFrame._uuid : null;
            serialized.sizeMode = component.sizeMode;
            serialized._spriteName = component.spriteFrame?.name;
        } else if (component instanceof cc.Label) {
            serialized.type = "cc.Label";
            serialized.string = component.string;
            serialized.fontSize = component.fontSize;
            serialized.lineHeight = component.lineHeight;
            serialized.horizontalAlign = component.horizontalAlign;
            serialized.verticalAlign = component.verticalAlign;
            serialized._fontName = component.font?.name;
        } else if (component instanceof cc.Animation) {
            serialized.type = "cc.Animation";
            // serialized.clips = component.clips.map((clip) => clip._uuid);
            serialized.clips = component.clips.map((clip) => clip.name);
        } else if (component instanceof cc.Mask) {
            serialized.type = "cc.Mask";
            serialized.type = component.type;
            serialized.segments = component.segments;
            serialized.inverted = component.inverted;
            // } else if (component instanceof sp.Skeleton) {
            //     serialized.type = "sp.Skeleton";
            //     // serialized.skeletonData = component.skeletonData ? component.skeletonData._uuid : null;
            //     serialized._skeName = component.skeletonData?.name; //只显示名字
            //     serialized.defaultSkin = component.defaultSkin;
            //     serialized.animation = component.animation;
            //     serialized.loop = component.loop;
            //     serialized.premultipliedAlpha = component.premultipliedAlpha;
            //     serialized.timeScale = component.timeScale;
        } else if (component instanceof cc.Widget) {
            serialized.type = "cc.Widget";
            serialized.isAlignTop = component.isAlignTop;
            serialized.isAlignBottom = component.isAlignBottom;
            serialized.isAlignLeft = component.isAlignLeft;
            serialized.isAlignRight = component.isAlignRight;
            serialized.isAlignHorizontalCenter = component.isAlignHorizontalCenter;
            serialized.isAlignVerticalCenter = component.isAlignVerticalCenter;
            serialized.top = component.top;
            serialized.bottom = component.bottom;
            serialized.left = component.left;
            serialized.right = component.right;
            serialized.horizontalCenter = component.horizontalCenter;
            serialized.verticalCenter = component.verticalCenter;
            serialized.alignMode = component.alignMode;
        } else if (component instanceof cc.Layout) {
            serialized.type = "cc.Layout";
            serialized.layoutType = component.type;
            serialized.resizeMode = component.resizeMode;
            serialized.cellSize = component.cellSize;
            serialized.startAxis = component.startAxis;
            serialized.paddingLeft = component.paddingLeft;
            serialized.paddingRight = component.paddingRight;
            serialized.paddingTop = component.paddingTop;
            serialized.paddingBottom = component.paddingBottom;
            serialized.spacingX = component.spacingX;
            serialized.spacingY = component.spacingY;
            serialized.verticalDirection = component.verticalDirection;
            serialized.horizontalDirection = component.horizontalDirection;
        } else {
            return null;
        }

        return serialized;
    }

    // Recursive function to serialize node tree
    function serializeTree(node) {
        const serializedNode = {
            name: node.name,
            active: node.active,
            position: { x: node.position.x, y: node.position.y },
            rotation: node.rotation,
            scale: { x: node.scale.x, y: node.scale.y },
            anchor: { x: node.anchorX, y: node.anchorY },
            contentSize: { width: node.width, height: node.height },
            // color: { r: node.color.r, g: node.color.g, b: node.color.b, a: node.opacity },
            children: [],
        };
        const spriteComp = node.getComponent(cc.Sprite);
        if (spriteComp) {
            serializedNode.color = { r: spriteComp.color.r, g: spriteComp.color.g, b: spriteComp.color.b }; //, a: spriteComp.opacity
        }

        const opacityComp = node.getComponent("cc.UIOpacity"); //参数传cc.UIOpacity获取不到，很奇怪
        if (opacityComp) {
            serializedNode.opacity = opacityComp.opacity;
        }

        const serializedComponents = [];
        const otherComponents = [];

        node.components.forEach((component) => {
            const serialized = serializeComponent(component);
            if (serialized) {
                serializedComponents.push(serialized);
            } else {
                let compClsName = component.__classname__;
                if (["cc.UIOpacity", "cc.UITransform"].indexOf(compClsName) < 0) {
                    otherComponents.push(compClsName);
                }
            }
        });

        if (serializedComponents.length > 0) {
            serializedNode.components = serializedComponents;
        }

        if (otherComponents.length > 0) {
            serializedNode.otherComponents = otherComponents;
        }

        node.children.forEach((child) => {
            serializedNode.children.push(serializeTree(child));
        });

        return serializedNode;
    }

    return serializeTree(node);
}

// Example usage
const node = new cc.Node(); // This should be your actual node
const serializedData = serializeNode(node);
console.log(JSON.stringify(serializedData, null, 2));
